# PR vCluster with Shared Argo CD

Both the PR vClsuter and the PR preview app are deployed by a shared Argo CD instance. The only thing deployed into the vCluster is the PR preview app itself.

## Flow 

1. A specific GitHub label is added to the Pull Request (this example uses `create-pr-vcluster-external-argocd`)
2. An Argo CD `ApplicationSet`, configured with the Pull Request generator, is triggered and generates an Argo CD `Application` specific to the given Pull Request and uses Kustomize to deploy a PR specific `VirtualClusterInstance` custom resource that leverages a `VitualClusterTemplate` custom resource for most of its configuration:

    - The Argo CD `ApplicationSet` allows using Pull Requests specific parameters with patches to kustomize the `VirtualClusterInstance` resource and is used to add the following `labels` for use with the PR preview app `ApplicationSet` to uniquely identify and target the PR vCluster:

      - `repo` the Pull Request GitHub repository
      - `prLabel` has to match `create-pr-vcluster-external-argocd` 
      - `prNumber` is the GitHub Pull Request number

5. As the vCluster is being created based on the `ApplicationSet` modified `VirutalClusterInstance`, the vCluster Platform integration triggers the creation of an Argo CD cluster `Secret` with the same `metadata.labels` that had been added to the PR vCluster `VirtualClusterInstance` custom resource
6. Once the Argo CD cluster `secret` is created with the necessary `metadata.labels`, it, along with the properly labeled Pull Request trigger the second Argo CD `ApplicationSet` that uses the Merge generator to merge the template parameters from the Clusters and Pull Request generators to generate an `Application` that will deploy the PR preview application into the PR vCluster
7. Additional commits to the Pull Request head branch will automatically update the second `Application` and depoy the updated container image with a tag based on the short commit sha of the last commit to the Pull Request head branch
8. If the Pull Request is merged or closed, or if the `create-pr-vcluster-external-argocd` label is removed, both `Applications` will be deleted resulting in the PR vCluster being deleted.

This example leverages the vCluster Platform Argo CD integration that automatically adds a vCluster instance to an Argo CD instance as an Application deployment server target to create dynamic ephemeral Kubernetes clusters for GitHub Pull Requests. This requires that the [Argo CD instance has been integrated with a vCluster Platform Project](https://www.vcluster.com/docs/platform/integrations/argocd#enable-argo-cd-integration-per-project). The vCluster Platform will then create an Argo CD Cluster `Secret` when a vCluster instance in the vCluster Platform Project is either manually or automatically added to the integrated Argo CD instance. This integration also includes the syncing of the `VirtualClusterInstance` Kubernetes custom resource definition (CRD) `metadata.labels` to the Argo CD Cluster `Secret`. These `labels` can then be used with the [Argo CD Application Set Cluster Generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Cluster/#pass-additional-key-value-pairs-via-values-field) as they are in this example.

This example also leverages two Argo CD ApplicationSets to dynamically create a virtual Kubernetes cluster (or vCluster) per Pull Request and deploy the Pull Request associated application to that vCluster. This example leverages two different Argo CD ApplicationSets: 
1. The first ApplicationSet is responsible for triggering the creation of the vCluster, that is automatically added to Argo CD as a cluster `destingation`, for the Pull Request.
2. The second ApplicationSet is responsible for deploying the example application to that vCluster.

> [!NOTE]
> The Argo CD ApplicationSet that creates the vCluster instance **does not** have to be deployed to an Argo CD instance that has been integrated with a vCluster Platform Project. However, the Argo CD instance where this ApplicationSet is added, does require the permission to create Kubernetes resources in the Kubernetes cluster where the vCluster Platform is installed - more specifically, it must be able to create the `VirtualClusterInstance` resources in a vCluster Platform Project `Namespace`. For this example, the `VirtualClusterInstance` will be created in the `p-auth-core` namespace which corresponds to the *Auth Core* Project and is the `metadata.namespace` value of the [example `VirtualClusterInstance` CRD](./kustomize/vcluster.yaml).
>
> The second Argo CD ApplicationSet must be applied to the same Argo CD instance that is integrated with the vCluster Platform Project where the Pull Request `VirtualClusterInstance` is created, as that resulting vCluster must be available as the destination cluster for the example application that is deployed by the Argo CD Appication generated by this ApplicationSet. This Argo CD instance could be the same as the one used for the first ApplicationSet, but it could also be a different Argo CD instance; just as long as it has been integrated with the vCluster Platform Project where the Pull Request vCluster is created.

### Components:
- vCluster Platform: leverages the `VirtualClusterInstance` CRD - [vcluster.yaml](./kustomize/vcluster.yaml), `VirtualClusterTemplate` CRD - the [Default Virtual Cluster Template](../../virtual-cluster-templates/vcluster-templates.yaml#L30), and `Project` CRD - [projects.yaml](../../projects/projects.yaml#L70-L131)
- vCluster instances: the `VirtualClusterInstance` created via the Argo CD Appication generated by this Application Set triggers the creation of a vCluster instance that is managed by the vCluster Platform and automatically added to Argo CD (by utilizing the `loft.sh/import-argocd` label) as an available Kubernetes cluster destination for deployments.
- Argo CD: One Argo CD instance is used in this example, and it is deployed to the same Kubernetes cluster where the vCluster Platform is deployed. The Argo CD instance is also [integrated with the *Auth Core* vCluster Platform Project](../../projects/projects.yaml#L120-L131). The example leverages [Argo CD ApplicationSets}(https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/) that use the [Pull Request Generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Pull-Request/) and the [Cluster Generator](https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators-Cluster/) to dynamically generate an Argo CD Application to deploy the demo application to the dynamic and ephemeral vCluster for any repostiory Pull Requests with the `create-pr-vcluster-external-argocd` label.
  
#### Argo CD ApplicationSets:
- **Pull Request Generator based ApplicationSet** ([pr-vcluster-external-argocd.yaml](./apps/pr-vcluster-external-argocd.yaml)) creates the vCluster instances via a Kustomize app that is automatically added as a server to an Argo CD instances that is intergrated with a vCluster Platform Project
  - A Pull Request label, `create-pr-vcluster-external-argocd` is used to filter Pull Requests and make the ephermeral preview environment opt in, instead of created for every repostiory pull request. This is optional.
  - **Kustomize App:** A Kustomize app is used to create the `VirtualClusterInstance` so that the *Pull Request Generator based ApplicationSet* may add dynamic labels that will then be applied to the Argo CD cluster `Secret` via the vCluster Platform integration, and eventually utilized by the *Cluster Generator based ApplicationSet*.
    - The `VirtualClusterInstance` includes the `metadata.label` `loft.sh/import-argocd: 'true'` that will trigger the vCluster Platform to automatically add the vCluster to the Argo CD instance that is configured with the vCluster Platform Project where the vCluster is created - in this example, that is the `auth-core` project. Also note that the `VirtualClusterInstance` uses a Virtual Cluster template per the `spec.templateRef` object. The `default-template` specified could have been configured to auto-add to Argo CD, by setting the `label` previously mentioned, that setting does not need to be enabled on the template. Additional `labels` are added dynamically with the Argo CD Pull Request Generator as described below.
  - The Pull Request Generator dynamic labels include:
    - `vclusterName`: Used to create a reference to this `VirtualClusterInstance` as the `server` URL value
    - `repo`: the repository for the GitHub Pull Request and the application code that needs to be deployed by Argo CD
    - `pr`: Set to 'true' and used as a filter for the *Cluster Generator based ApplicationSet* so that only Pull Request ephemeral vCluster instances will trigger the generate of an Argo CD `Application` to deploy the Pull Request association application
    - `headBranch`: The head branch of the Pull Request. This is used to pull the correct container image (from the GitHub Container Registry for this example) associated with the Pull Request. The head branch is used insteat of the commit sha because the Pull Request vCluster will not be recreated for any new commits to the head branch of the Pull Request but the commits to the head branch will trigger a new container image build and a redeployment by Argo CD. The `headBranch` is also used as the `targetRevision` value for the *Cluster Generator based ApplicationSet* described below.
    - `targetRevision`: The commit SHA of the Pull Request head branch to target for the generated Argo CD `Application`
    - `headShortSha`: The short, 8 character, version of the commit SHA of the Pull Request head branch. This is only used in the output of the example app.
- **Cluster Generator based ApplicationSet** ([pr-preview-app-cluster-operator.yaml](./apps/pr-preview-app-cluster-operator.yaml)) uses labels, dynamically added to the `VirtualClusterInstance` created with the Pull Request Generator based ApplicationSet, to deploy the actual application code associated with the head commit of the Pull Request (in this example it is a [Helm based application](../../../helm-chart/)
